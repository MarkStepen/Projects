*********************************************
脉搏心率测试
2015-9-8
*********************************************
涉及的知识点：

1、ADC
采用外部触发，触发源为TIM3，由TIM3触发启动，每个定时周期结束后触发一次

2、TIM3
*定时周期2ms,
*选择定时器触发输出模式
*选择update event 作为TRGOSource，即触发输出源,作为ADC的外部触发源，触发ADC通道

*********************************************
初级版
1、ADC采用软件触发而不是外部触发
2、定时器没有选择输出触发模式
3、ADC在初始化的时候就已经启动

(1)主要思路：
程序开始运行，定时器和ADC就一直在工作，ADC不断采集数据（每21us），而定时器一直在计时，当计时2ms进入中断程序，此时主程序暂停，即ADC停止工作，当中断程序执行完后，回到主程序，ADC才又重新工作。
(2)出现的问题：
   数据不稳定，波动比较大;
   进入中断前，ADC一直在工作，但是被采用的数据只有在中断来临时，ADC停止工作的时候保存的最新的值，浪费了CPU功耗。
(3)第一次修改：
将ADC的启动和关闭代码，封装成一个函数，然后在进入中断的时候进行调用，这样一来，每进入一次中断，启动一次ADC，得到一个AD值，并关闭ADC，然后对得到的AD值进行处理。
(4)意义：
节省了CPU的功耗，因为ADC不用一直在工作，而是每2ms才进行一次转换。
2015-8-27
************************************************
优化版

(1)第二次修改：
定时器采用了输出触发模式，ADC采用外部触发启动。
采用TIM3输出触发启动ADC，即进入中断的同时启动ADC进行转换并关闭ADC.
(2)这样一来,TIM3作为ADC的外部触发源，程序开始运行，定时器开始计时，计时2ms，进入中断，同时触发启动ADC进行一次AD转换，得到一个AD值，在中断程序里，对采集到的AD值进行处理，然后回到主程序，同时继续计时。
(3)优化后：
数据较稳定，波动较小。

2015-9-8
************************************************